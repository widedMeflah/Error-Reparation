# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11tzjJRQ654HfVJlUi9ls3K0h23U9u4JO
"""

df = pd.read_csv('/content/drive/MyDrive/PFE/Copie de Hospital_100k_Clean.csv')
print(df)
df = df.drop(columns=['row_num'])

# Exemple d'utilisation avec une liste de contraintes erronées

#"PhoneNumber → State" de 1 à 6


contrainte_erronee = ["MeasureCode  → City","PhoneNumber → City, Condition"]
contraintes_systemes_avant = ["MeasureCode  → City","PhoneNumber → City, Condition", "MeasureCode → Condition, City", "MeasureCode → MeasureName, City", "PhoneNumber → ZIPCode, Condition", "MeasureCode, State → StateAvg, ZIPCode","ZIPCode, State → StateAvg","PhoneNumber → MeasureName","MeasureCode → StateAvg","MeasureCode, ZIPCode  → State","PhoneNumber, StateAvg  → State"]
contraintes_reparees= Reparer(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")

# Exemple d'utilisation avec une liste de contraintes erronées

#"PhoneNumber → State"  7


contrainte_erronee = ["City, State → StateAvg", ]
contraintes_systemes_avant = [
"ZIPCode → State",
"PhoneNumber → ZIPCode",
"MeasureCode → MeasureName",
"MeasureCode → Condition",
"PhoneNumber → City",
"PhoneNumber → State","MeasureCode → StateAvg","State → StateAvg"]
contraintes_reparees, contraintes_choisies = Reparer(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")

# Exemple d'utilisation avec une liste de contraintes erronées

# 8


contrainte_erronee = ["PhoneNumber → MeasureName"]
contraintes_systemes_avant = [
"ZIPCode → State"]
contraintes_reparees, contraintes_choisies = Reparer(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")

# Exemple d'utilisation avec une liste de contraintes erronées

#"PhoneNumber → State"
#ZIPCode → State  9 et 10

contrainte_erronee = ["ZIPCode → State, Condition","PhoneNumber, StateAvg  → State"]
contraintes_systemes_avant = ["StateAvg, PhoneNumber, ZIPCode → State"]
contraintes_reparees, contraintes_choisies = Reparer(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")

# Exemple d'utilisation avec une liste de contraintes erronées

#State, MeasureName → StateAvg  11


contrainte_erronee = ["State → StateAvg"]
contraintes_systemes_avant = [
"ZIPCode → State",
"PhoneNumber → ZIPCode",
"MeasureCode → MeasureName",
"MeasureCode → Condition",
"PhoneNumber → City",
"PhoneNumber → State","MeasureCode → StateAvg","State → StateAvg"]
contraintes_reparees, contraintes_choisies = Reparer(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")

def evaluer_temps_execution(df, liste_contraintes_erronees, contraintes_systemes):
    debut_execution = time.time()
    contraintes_reparees, contraintes_reparees_hybride = Reparer(df, liste_contraintes_erronees, contraintes_systemes)
    fin_execution = time.time()

    temps_execution = fin_execution - debut_execution
    return temps_execution, contraintes_reparees, contraintes_reparees_hybride







contrainte_erronee = ["State → StateAvg"]
contraintes_systemes_avant = [
"ZIPCode → State",
"PhoneNumber → ZIPCode",
"MeasureCode → MeasureName",
"MeasureCode → Condition",
"PhoneNumber → City",
"PhoneNumber → State","MeasureCode → StateAvg","State → StateAvg"]
# Évaluer le temps d'exécution et obtenir les résultats de réparation
temps_execution, contraintes_reparees, contraintes_choisies = evaluer_temps_execution(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")
# Afficher le temps d'exécution
print(f"Temps d'exécution total : {temps_execution} secondes")

def evaluer_temps_execution(df, liste_contraintes_erronees, contraintes_systemes):
    debut_execution = time.time()
    contraintes_reparees, contraintes_reparees_hybride = Reparer(df, liste_contraintes_erronees, contraintes_systemes)
    fin_execution = time.time()

    temps_execution = fin_execution - debut_execution
    return temps_execution, contraintes_reparees, contraintes_reparees_hybride







contrainte_erronee = ["MeasureCode  → City","PhoneNumber → City, Condition", "MeasureCode → Condition, City", "MeasureCode → MeasureName, City"]
contraintes_systemes_avant = ["MeasureCode  → City","PhoneNumber → City, Condition", "MeasureCode → Condition, City", "MeasureCode → MeasureName, City"]
# Évaluer le temps d'exécution et obtenir les résultats de réparation
temps_execution, contraintes_reparees, contraintes_choisies = evaluer_temps_execution(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")
# Afficher le temps d'exécution
print(f"Temps d'exécution total : {temps_execution} secondes")

def evaluer_temps_execution(df, liste_contraintes_erronees, contraintes_systemes):
    debut_execution = time.time()
    contraintes_reparees, contraintes_reparees_hybride = Reparer(df, liste_contraintes_erronees, contraintes_systemes)
    fin_execution = time.time()

    temps_execution = fin_execution - debut_execution
    return temps_execution, contraintes_reparees, contraintes_reparees_hybride






contrainte_erronee = ["MeasureCode  → City","PhoneNumber → City, Condition", "MeasureCode → Condition, City", "MeasureCode → MeasureName, City", "PhoneNumber → ZIPCode, Condition", "MeasureCode, State → StateAvg, ZIPCode","ZIPCode → State, Condition","PhoneNumber, StateAvg  → State"]
contraintes_systemes_avant = ["MeasureCode  → City","PhoneNumber → City, Condition", "MeasureCode → Condition, City", "MeasureCode → MeasureName, City", "PhoneNumber → ZIPCode, Condition", "MeasureCode, State → StateAvg, ZIPCode","ZIPCode, State → StateAvg","PhoneNumber → MeasureName","MeasureCode → StateAvg","MeasureCode, ZIPCode  → State","PhoneNumber, StateAvg  → State"]
# Évaluer le temps d'exécution et obtenir les résultats de réparation
temps_execution, contraintes_reparees, contraintes_choisies = evaluer_temps_execution(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")
# Afficher le temps d'exécution
print(f"Temps d'exécution total : {temps_execution} secondes")

df = pd.read_csv('/content/drive/MyDrive/PFE/Taxclean5k.csv')

df = df.drop(columns=['row_num'])

# Exemple d'utilisation avec une liste de contraintes erronées
"state → zip"
"city → zip"
"city, state → zip"
"state → zip, city"
"city  → state, zip"


contrainte_erronee = ["state → city","city → state","city, zip → state","zip, state → city","zip → city, state"]

contraintes_systemes_avant = ["state → city","city → state","city, zip → state","zip, state → city","zip → city, state","state → zip","city → zip","city, state → zip","state → zip, city","city  → state, zip"]
contraintes_reparees, contraintes_choisies = Reparer(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")

def evaluer_temps_execution(df, liste_contraintes_erronees, contraintes_systemes):
    debut_execution = time.time()
    contraintes_reparees, contraintes_reparees_hybride = Reparer(df, liste_contraintes_erronees, contraintes_systemes)
    fin_execution = time.time()

    temps_execution = fin_execution - debut_execution
    return temps_execution, contraintes_reparees, contraintes_reparees_hybride







contrainte_erronee = ["state → city"]

contraintes_systemes_avant = ["state → city","city → state","city, zip → state","zip, state → city","zip → city, state","state → zip","city → zip","city, state → zip","state → zip, city","city  → state, zip"]
# Évaluer le temps d'exécution et obtenir les résultats de réparation
temps_execution, contraintes_reparees, contraintes_choisies = evaluer_temps_execution(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")
# Afficher le temps d'exécution
print(f"Temps d'exécution total : {temps_execution} secondes")

def evaluer_temps_execution(df, liste_contraintes_erronees, contraintes_systemes):
    debut_execution = time.time()
    contraintes_reparees, contraintes_reparees_hybride = Reparer(df, liste_contraintes_erronees, contraintes_systemes)
    fin_execution = time.time()

    temps_execution = fin_execution - debut_execution
    return temps_execution, contraintes_reparees, contraintes_reparees_hybride







contrainte_erronee = ["state → city","city → state","city, zip → state"]

contraintes_systemes_avant = ["state → city","city → state","city, zip → state","zip, state → city","zip → city, state","state → zip","city → zip","city, state → zip","state → zip, city","city  → state, zip"]
# Évaluer le temps d'exécution et obtenir les résultats de réparation
temps_execution, contraintes_reparees, contraintes_choisies = evaluer_temps_execution(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")
# Afficher le temps d'exécution
print(f"Temps d'exécution total : {temps_execution} secondes")

def evaluer_temps_execution(df, liste_contraintes_erronees, contraintes_systemes):
    debut_execution = time.time()
    contraintes_reparees, contraintes_reparees_hybride = Reparer(df, liste_contraintes_erronees, contraintes_systemes)
    fin_execution = time.time()

    temps_execution = fin_execution - debut_execution
    return temps_execution, contraintes_reparees, contraintes_reparees_hybride







contrainte_erronee = ["state → city","city → state","city, zip → state","zip, state → city","zip → city, state"]

contraintes_systemes_avant = ["state → city","city → state","city, zip → state","zip, state → city","zip → city, state","state → zip","city → zip","city, state → zip","state → zip, city","city  → state, zip"]
# Évaluer le temps d'exécution et obtenir les résultats de réparation
temps_execution, contraintes_reparees, contraintes_choisies = evaluer_temps_execution(df, contrainte_erronee, contraintes_systemes_avant)

for contrainte_erronee, contrainte_reparee in contraintes_reparees:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation: {contrainte_reparee}")
for contrainte_erronee, contrainte_choisie in contraintes_choisies:
    print(f"Contrainte erronée : {contrainte_erronee} => sa réparation hybride: {contrainte_choisie}")
# Afficher le temps d'exécution
print(f"Temps d'exécution total : {temps_execution} secondes")

def calcule_precision_rappel(df_original, df_repare, lignes_erronees):
    # Calculez la précision en comparant les DataFrames
    cellules_correctement_reparees = (df_original == df_repare).sum().sum()
    cellules_totales_reparees = df_repare.size
    precision = cellules_correctement_reparees / cellules_totales_reparees

    # Calculez le rappel en comparant les lignes erronées avec le DataFrame réparé
    cellules_correctement_reparees = ((df_original == df_repare) & lignes_erronees).sum().sum()
    cellules_totales_erronees = lignes_erronees.sum().sum()
    rappel = cellules_correctement_reparees / cellules_totales_erronees

    return precision, rappel

# Exemple d'utilisation
fd_erronee = "MeasureCode → City"
lignes_violantes = verifie_dependances(df, fd_erronee)
df_repare = reparehyp(fd_erronee, lignes_violantes, df)
precision, rappel = calcule_precision_rappel(df, df_repare, lignes_violantes)

print("Précision:", precision)
print("Rappel:", rappel)

# Exemple d'utilisation
fd_erronee = "MeasureCode → Condition, City"
lignes_violantes = verifie_dependances(df, fd_erronee)
df_repare = reparehyp(fd_erronee, lignes_violantes, df)
precision, rappel = calcule_precision_rappel(df, df_repare, lignes_violantes)

print("Précision:", precision)
print("Rappel:", rappel)

# Exemple d'utilisation
fd_erronee = "State → StateAvg"
lignes_violantes = verifie_dependances(df, fd_erronee)
df_repare = reparehyp(fd_erronee, lignes_violantes, df)
precision, rappel = calcule_precision_rappel(df, df_repare, lignes_violantes)

print("Précision:", precision)
print("Rappel:", rappel)

Test réparation hybride tax

# Exemple d'utilisation
fd_erronee = "city, zip → state"
lignes_violantes = verifie_dependances(df, fd_erronee)
df_repare = reparehyp(fd_erronee, lignes_violantes, df)
precision, rappel = calcule_precision_rappel(df, df_repare, lignes_violantes)

print("Précision:", precision)
print("Rappel:", rappel)

# Exemple d'utilisation
fd_erronee = "city → state"
lignes_violantes = verifie_dependances(df, fd_erronee)
df_repare = reparehyp(fd_erronee, lignes_violantes, df)
precision, rappel = calcule_precision_rappel(df, df_repare, lignes_violantes)

print("Précision:", precision)
print("Rappel:", rappel)

def evaluate_classifier(X_train, y_train, X_test, y_test, algorithm):
    if algorithm == "LogisticRegression":
        classifier = LogisticRegression()
    elif algorithm == "SVM":
        classifier = SVC()
    elif algorithm == "RandomForest":
        classifier = RandomForestClassifier()
    elif algorithm == "DecisionTree":
        classifier = DecisionTreeClassifier()
    else:
        raise ValueError("Algorithm not supported")

    # Entraînez le modèle sur l'ensemble de formation
    classifier.fit(X_train, y_train)

    # Faites des prédictions sur l'ensemble de test
    y_pred = classifier.predict(X_test)

    # Calculez les mesures de performance
    precision = precision_score(y_test, y_pred, average='weighted')
    recall = recall_score(y_test, y_pred, average='weighted')
    f1 = f1_score(y_test, y_pred, average='weighted')

    return precision, recall, f1

def train_and_evaluate_classifiers(dataframe, dependances, algorithms):
    resultatt = verifie_dependances(dataframe, dependances)
    resultat = statistique1(dataframe, resultatt)
    statitstique2 = statistique2(dataframe, dependances, resultat)

    X = statitstique2[["TailleViolations", "Moyenne"]]
    y = statitstique2["class"]

    # Encoder les labels de classe si nécessaire
    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(y)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    results = {}

    for algorithm in algorithms:
        precision, recall, f1 = evaluate_classifier(X_train, y_train, X_test, y_test, algorithm)
        results[algorithm] = {
            "Precision": precision,
            "Recall": recall,
            "F1 Score": f1
        }

    return results

# Liste des classifieurs à évaluer
algorithms_to_evaluate = ["LogisticRegression", "SVM", "RandomForest", "DecisionTree"]

# Exemple d'utilisation :
results = train_and_evaluate_classifiers(dataframe, dependances, algorithms_to_evaluate)

# Afficher les résultats
for algorithm, metrics in results.items():
    print(f"Classifier: {algorithm}")
    print(f"Precision: {metrics['Precision']}")
    print(f"Recall: {metrics['Recall']}")
    print(f"F1 Score: {metrics['F1 Score']}")
    print()

# Liste des classifieurs à évaluer
algorithms_to_evaluate = ["LogisticRegression", "SVM", "RandomForest", "DecisionTree"]

# Appeler la fonction avec le DataFrame "fd" et les classifieurs
results = train_and_evaluate_classifiers(fd, dependances, algorithms_to_evaluate)

# Afficher les résultats
for algorithm, metrics in results.items():
    print(f"Classifier: {algorithm}")
    print(f"Precision: {metrics['Precision']}")
    print(f"Recall: {metrics['Recall']}")
    print(f"F1 Score: {metrics['F1 Score']}")
    print()